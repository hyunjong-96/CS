# 데이터베이스 



<br>

-----------------------

### DB & DBMS

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />



-----------------------

+ DB (DataBase)
  + 파일 시스템의 데이터 중복, 비 일관성, 검색 등의 문제를 해결하기 위해 구조화된 데이터 집합

+ DBMS (DataBaseManagementSystem)
  + 여러 사용자들이 DB를 사용할 수 있도록 해주는 소프트웨어

+ 스키마
  + 데이터베이스의 구조와 제약조건 등의 명세를 기술한 메타 데이터 집합



</details>

-----------------------

<br>



<br>

-----------------------

### 무결성

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />



-----------------------

+ 데이터의 정확성, 일관성을 보장하는 것
  + 정확성 : 중복과 누락없는 것
  + 일관성 : 성질이 변하지 않고 유지되는 것

+ 무결성 제약 조건 종류
  + 개체 무결성
    + 기본키는 Null일 수 없고, 하나의 값만 존재해야한다.

  + 참조 무결성
    + 외래키를 참조할 수 없는 값을 가질 수 없다. Null이나 fk만 허용한다.

  + Null 무결성
    + 특정 속성은 Null을 가질 수 없다.

  + 고유 무결성
    + 특정 속성은 중복되는 값을 가질 수 없다.

  + 키 무결성
    + 하나의 테이블에는 적어도 하나의 키가 있어야한다.

  + 도메인 무결성
    + 속성값은 해당 속성의 도메인에 속한 값이어야한다.
    + 성별 속성은 무조건 남,녀만 와야한다.



</details>

-----------------------

<br>



<br>

-----------------------

### Key

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />



-----------------------

+ 튜블플 구분할수 있는 유일한 속성
+ 종류
  + 슈퍼키 : 유일성을 만족하는 속성
  + 후보키 : 유일성과 최소성을 만족하는 속성
  + 기본키 : 후보키 중에서 선택한 속성, 특정 튜플을 유일하게 식별할수 있는 속성이며 Null을 허용하지 않는다.
  + 대체키 : 기본키를 제외한 나머지 후보키
  + 외래키 : 다른 튜플을 식별할 수 있는 속성



</details>

-----------------------

<br>



<br>

-----------------------

### 외래키와 참조 무결성

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />



-----------------------

+ 외래키는 참조 무결성을 지키기 위해 restricted, cascade와 같은 개념을 적용할 수 있다.
+ restricted
  + 수정 삭제시, 참조하고 있는 개체가 있다면 연산을 취소

+ cascade
  + 수정 삭제시, 참조하고 있는 개체도 함께 수정 또는 삭제



</details>

-----------------------

<br>



<br>

-----------------------

### 정규화

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />



-----------------------

+ 이상현상을 제거하기 위해 테이블을 분리하는 작업
+ 이상현상
  + 삽입 이상
    + 특정 데이터가 존재하지 않아 추가하고 싶은 데이터를 추가하지 못하는 현상

  + 삭제 이상
    + 특정 데이터를 삭제할때 원치 않은 데이터도 삭제되는 현상

  + 갱신 이상
    + 데이터를 수정했는데 같은 속성이지만 다른 값을 가지는 불일치성이 생기는 현상

+ 종류
  + 제 1정규화
    + 모든 속성값은 원자성을 갖는다.

  + 제 2정규화
    + 제 1정규화 + 완전 함수정 종속
    + 완전 함수정 종속 : 기본키의 부분집합이 결정자이지 않는것

  + 제 3정규화
    + 제 2정규화 + 이행적 종속이 아닌것
    + 이행적 종속 : a->b, b->c 일때 a->c인것.

  + BCNF
    + 제 3정규화 + 모든 결정자가 후보키



</details>

-----------------------

<br>



<br>

-----------------------

### 반 정규화

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />



-----------------------

+ 의도적으로 정규화를 위배해 성능 향상 및 편의성을 이루는 과정
+ 시스템의 성능이 향상될 수 있지만 데이터의 일관성은 저하될 수 있다.
+ 장점
  + Join비용이 줄어들어 빠른 조회가 가능하다.
  + 조회 쿼리가 간단해진다.

+ 단점
  + 데이터의 삽입, 삭제, 수정의 비용이 비싸다
  + 데이터를 중복저장하여 더 많은 저장공간이 필요.



</details>

-----------------------

<br>



<br>

-----------------------

### 트랜잭션

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />



-----------------------

+ 데이터베이스의 상태를 변경하기 위한 작업 단위
+ 특징 (ACID)
  + 원자성 (Automicity)
    + 트랜잭션의 결과는 모두 반영되거나 모두 반영되지 않아야한다.

  + 일관성 (Consistency)
    + 트랜잭션의 결과고 데이터베이스의 상태가 모순되지 않아야한다.

  + 격리성 (Isolation)
    + 트랜잭션이 자원을 사용하고있다면 다른 트랜잭션의 접근을 제한하는것.

  + 지속성 (Durability)
    + 트랜잭션이 성공정으로 수행되면 결과는 데이터베이스에 영구적으로 저장된다.



</details>

-----------------------

<br>



<br>

-----------------------

### 회복

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />



-----------------------

+ 문제가 발생했을 때 Rollback이 수행되고 UNDO, REDO가 발생하여 문제가 발생되기 전 상태로 돌아가는 것
+ check point
  + 로그 파일에 체크포인트를 저장하고 문제 발생시 check point 이후에 처리된 작업들을 회복시키는 것.

+ UNDO
  + 트랜잭션이 commit되지 않은 상태에서 문제 발생시, 해당 작업이 없던 일로 처리하는 작업

+ REDO
  + 트랜잭션이 commit된 후 문제 발생시, REDO로 check poin지점으로 돌아가 저장된 로그를 통해 commit지점까지 복구하는 작업.



</details>

-----------------------

<br>



<br>

-----------------------

### 트랜잭션 격리성 문제

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />



-----------------------

+ 동시에 여러 트랜잭션이 수행 될 때 각 트랜잭션이 얼마만큼의 고립성을 가지는지 나타내는 것
+ 사용 이유
  + 동시성과 일관성을 유지하기 위함으로써, 일관성이 너무 높으면 병목 현상이 발생하여 응답이 지연되고, 동시성이 너무 높으면 데이터가 꼬일 위험이 있게 된다. 동시성과 일관성을 적절히 맞추기 위해 사용하는 방법 중 하나가 트랜잭션 격리이다.

+ 종류
  + Read UnCommited
    + 데이터를 변경한 트랜잭션의 commit, rollback 여부 상관없이 트랜잭션에게 보여주는 격리성 수준

  + Read Commited
    - commit을 수행한 트랜잭션의 결과만 조회할 수 있는 격리 수준
    - orcle의 격리 수준
    - Commit() 이후의 데이터만 읽을 수 있기 때문에 Dirty Read는 발생하지 않는다.
    - 다른 트랜잭션이 수정 중인 데이터는 Undo영역의 데이터를 읽어오고, commit()된 후의 데이터를 조회할 때는 Record영역의 데이터를 읽어 오기 때문에 Non Repetable Read와 Phantom Read 가 발생한다.
  + Repetable Read
    + 트랜잭션의 ID를 부여하여 자신 보다 낮은 ID의 트랜잭션 결과만 조회하는 격리 방식
    + MySQL의 격리 수준
    + 데이터 변경시 이전 데이터를 트랜잭션 ID와 함께 Undo영역에 저장하고 변경된 데이터는 Record 영역에 저장한다.
      + 이러한 변경 방식을 MVCC (Multiple Version Concurrency Control)이라고 한다.

    + 트랜잭션 ID를 통해 Repetable Read가 발생하지 않는다.

  + Serializable
    + 읽기 작업과 쓰기 작업 모두 락을 걸어 다른 트랜잭션은 해당 자원에 접근할 수 없다
    + 일관성이 가장 높고 동시성이 가장 낮은 격리 수준



</details>

-----------------------

<br>



<br>

-----------------------

### Lock

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />



-----------------------

+ Lock이란 트랜잭션 처리의 순차성을 보장하기 위한 방법.
+ 종류
  + 공유 락 (S- Lock)
    + 데이터를 읽을 때 사용되는 락.
    + S-Lock이 걸려있을때 S-Lock는 동시 접근이 가능하다. 하지만 L-Lcok은 접근이 불가능하다.
    + SELECT

  + 베타 락 (Exclusive - Lock)
    + 데이터를 변경 할 때 사용되는 락
    + X-Lock이 해제될 때까지 다른 트랜잭션은 해당 자원에 접근이 불가능하다.
    + SELECT for UPDATE, UPDATE, DELETE

+ 락의 해제 타이밍
  + commit
  + rollback



</details>

-----------------------

<br>



<br>

-----------------------

### Index

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />



-----------------------

+ 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스의 검색 속도를 향상시키기 위한 자료구조
+ Indexing을 사용하지 않으면 조회시 Table Full Scan으로 검색 속도가 느리다.
+ Index의 컬럼 선정 기준
  + 카디널리티가 높은 컬럼 (중복도가 낮은 컬럼)
  + 이유
    + 인덱싱의 최대 효율을 내기 위해 Index로 많은 부분을 걸러내야하기 때문이다

  + Index의 복수 컬럼 선정
    + 카디널리티가 높은 순으로 선정한다.

+ 자료구조
  + 해시 테이블
    + key에 대한 해시코드를 통해 데이터를 찾아 O(1)의 시간이 걸린다.
    + 해시 테이블은 등호연산(=)일때는 효율적이지만 부등호(>,<)연산시 효율적이지 못하다.

  + B - Tree
    + Root Node, Brach Node, Leaf Node로 구성되어있다.
    + 하나의 노드에 key와 데이터가 저장되어있다.
    + 장점
      + 노드에 데이터가 저장되어있어 메모리에서 바로 데이터를 가져올 수 있다.
      + key가 정렬되어있어 부등호 연산에 효율적이다.

  + B + Tree
    + Inner Node와 Leaf Node로 구성되어있다.
    + Inner Node에 key만 정렬되서 저장되어있고 데이터는 Leaf Node에 LinkedList로 연결되어 저장되어있다.
    + 장점
      + Leaf Node가 LinkedList로 연결되어있어 선형탐색이 가능하고 부등호 연산에 효율적이다.


</details>

-----------------------

<br>



<br>

-----------------------

### Scan

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />



-----------------------

+ Table Full Scan
  + 테이블의 속한 값을 모두 읽어 원하는 값을 찾는다.

+ Index Range Scan
  + leaft node까지 수직 탐색 후, LinkedList를 이용해서 범위 탐색이 가능하다.

+ Index Full Scan
  + 모든 값을 읽지않고 Index만 읽어서 탐색할 수 있기 때문에 Table Full Scan보다 비용이 저렴하다.
  + 첫번째 leaft node까지 수직 탐색 후,  리프 노드 전체를 탐색



</details>

-----------------------

<br>



<br>

-----------------------

### 관계형 DB, No SQL

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />



-----------------------

- RDB (Relation Data Base)
  - 정해진 스키마에 따라 데이터를 테이블에 저장하는 데이터베이스
  - 데이터 구조를 보장하고 중복을 방지한다.
  - 테이블간의 연관관계를 가진다.
  - 수직적 확장이 가능하다 (성능 향상)
  - 사용
    - 관계를 맺고 있는 데이터의 수정이 빈번한 경우
    - 명확한 스키마가 데이터와 사용자에게 중요한 경우
- No SQL
  - 유연한 스키마로 데이터간의 관계없이 자유로운 형태로 데이터를 저장하는 데이터베이스
  - 수평적 확장으로 트랜픽 분산 및 대용량 처리가 가능하다.
  - 사용
    - 읽기를 많이하고 수정, 삭제가 많이 없는 경우
    - 데이터베이스를 수평적으로 확장해야 하는 경우 (막대한 양의 데이터를 다룸)


</details>

-----------------------

<br>



<br>

-----------------------

### Redis, Memcached

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />



-----------------------

+ Redis
  + In Memory 데이터베이스로  key,value 형태로 데이터를 저장하는 NoSQL이다.
  + 여러가지 자료구조, 싱글스레드, 복구 기능을 제공한다.
  + 확장가능한 웹 애플리케이션 구축과 고급데이터 구조 사용시 사용한다.

+ Memcached
  + In Memory 데이터베이스로 key,value 형태로 데이터를 저장하는 NoSQL이다.
  + 멀티 스레드를 지원하며, 애플리케이션 속도를 높일때 사용한다.



</details>

-----------------------

<br>



<br>

-----------------------

### Elastic Search

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />



-----------------------

+ 자바 기반의 오픈 소스 검색 엔진으로 역색인을 통해 방대한 양의 데이터를 빠르게 검색, 저장할 수 있다.
+ <img width="446" alt="image" src="https://user-images.githubusercontent.com/57162257/185732856-30c0b5c3-d2e3-4ce1-80f5-225017db987b.png">
+ 역색인
  + 텍스트를 파싱해서 단어를 분리하여 검색어 사전에 저장한다.
  + 검색어 사전에는 단어별로 Document를 가리키고 있다.

+ 구조
  + Cluster
    + Elastic Search에서 가장 큰 시스템 단위
    + 하나 이상의 Node를 가지고 있으며, Cluster끼리는 통신이 불가능하다.

  + Node
    + 하나의 단위 프로세스로써 Index 생성, 데이터 CRUD 등의 역할에 따라 노드를 나눈다.

  + Index
    + 데이터베이스와 대응하는 개념
    + Index = DataBase, Type = Table, Field = Colume, Document = Row

  + Shard
    + 샤딩을 통해 Index를 분리하여 저장한 형태
    + 스케일 아웃을 위해 index를 여러 shard로 나눈다.

  + Replica
    - Node의 손실을 대비하기 위해 shard를 여러 Node에 저장한 것.

+ 특징
  + Scale Out
    + 샤드를 통해 수평적 확장

  + 고가용성
    + 레플리카를 통해 안정성 보장

  + Schema Free
    + Json문서로 검색하기 때문에 스키마가 없다.

  + Rest Ful
    + 데이터 crud 작업은 http restful api를 사용한다.
    + SELECT = Get, Create = Put, UPDATE = Post, DELETE = Delete



</details>

-----------------------

<br>



<br>

-----------------------

### Elastic Search & RDBMS의 Like

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />



-----------------------

+ RDBMS의 Like는 전체검색으로 단순 텍스트 매칭에 대한 결과를 반환
+ Elastic Search는 전체검색이 아닌 역색인 기반으로 검색하기 때문에 빠르다.


</details>

-----------------------

<br>



<br>

-----------------------

### 샤딩

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />



-----------------------

+ 큰 테이블을 수평으로 쪼개어 다른 데이터베이스에 저장하는 방법
+ 장점
  + 데이터와 Index의 개수가 줄어들어 성능이 향상된다.

+ 단점
  + 데이터베이스 간의 통신이 많아져 비용 증가
  + 하나의 서버가 고장나면 무결성이 깨질 수 있다.



</details>

-----------------------

<br>



<br>

-----------------------

### 수평 파티셔닝

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />



-----------------------

+ 테이블을 수평으로 나누어 스키마가 동일한 여러 테이블을 만드는것.
+ 장점
  + 데이터와 Index의 개수가 줄어들어 성능이 향상된다.

+ 단점
  + 데이터를 찾는 과정이 기존보다 복잡해 처리 시간이 증가한다.



</details>

-----------------------

<br>



<br>

-----------------------

### 수직 파티셔닝

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />



-----------------------

+ 테이블을 수직으로 나누어 여러 테이블로 분리하는 방식
+ 장점
  + 자주 사용하는 컬럼을 분리시켜 조회시 필요없는 데이터가 올라오는 것을 줄여 성능을 높여준다.

+ 단점
  + 테이블간 조인 비용 발생



</details>

-----------------------

<br>



<br>

-----------------------

### RabbitMQ & Kafka

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />



-----------------------

+ Message Queue 기반의 메시지 시스템
+ Message Queue
  + 프로세스간 데이터를 교환할 때 사용하는 통신 방법
  + 장점
    + 비동기 : 메시지를 queue에 저장
    + 낮은 결합도 : 애플리케이션과 분리
    + 탄력성 : consumer가 고장나도 메시지는 queue에 저장되어있음
    + 보장성 : MQ에 저장되면 모든 메시지는 consumer에게 전달 보장

+ Kafka
  + 메시지 큐 기반의 분산 메시징 시스템
  +  Publisher와 Subscriber를 중심으로 생성자가 원하는 메시지를 배포 패턴으로 진행
  + 메시지를 Subscriber가 가져가도 broker에서는 메시지를 저장하고 있어 다시 사용가능
  + 메시지를 병렬 처리하기 때문에 대용량 데이터 처리 가능

+ RabbitMQ
  + AMQP 프로토콜을 구현한 메시지 브로커
  + 브로커 중심적 형태로 publisher와 consumer간 보장된 메시지 전달에 초점
  + 메시지를 consumer에게 전달하면 삭제
  + 데이터 처리보다 Manage UI를 제공해 관리나 다양한 기능 제공을 위한 서비스 구축에 사용



</details>

-----------------------

<br>





