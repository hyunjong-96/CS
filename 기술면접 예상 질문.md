# 기술 면접 리스트



# Java



## #1 Java란 무엇인가

---



## #2 Compiler 와 Interpreter 차이

---



## #3 컴파일 과정

---



## #4 OOP

---



## #5 String과 StringBuilder와 StringBuffer

---



## #6 thread safe

---



## #7 자바 접근 제어자

---



## #8 캡슐화와 은닉화

---



## #9 클래스, 객체, 인스턴스 차이





---

# Spring



## #1 spring 프레임워크는 왜 만들어졌는가

초기 서버사이드는 스레드, 소켓 등을 개발자가 직접 처리해야했고 개발자 마다 구현방법이 달랐기 때문에 협업에 불편한 사항이 많았습니다.

이런 문제를 해결하기 위해 개발 표준을 삼은 것이 Java Enterprise Edition이고 개발자는 이 스펙을 가지고 Servlet, JSP 등을 이용해 서버를 개발하기 시작했습니다. 하지만 이러한 기술을 구현하는 방법이 나뉘게 되었고 이를 정형화, 표준화하는 방법을 찾기 시작했고 이것의 결과로 프레임워크가 탄생하게 되었습니다.

즉, 자바를 이용해 정영화되고 표준화된 구조와 기술을 사용하여 개발자가 비즈니스 로직에 좀 더 집중 할 수 있는 환경을 제공하는 것이 자바 엔터프라이즈 프레임워크인 스프링 프레임워크가 만들어졌고 사용되고 있습니다.

---



## #2 spring DI 이란 무엇인가

제어의 역전(IOC)을 통해 특정 객체에 필요한 다른 객체를 내부에서 생성하는 것이 아닌 외부에서 주입하는것을 말합니다.

의존성 주입을 위해 주입될 객체는 spring container에서 관리되는 빈으로 등록되어있어야 하며 주입 방법은 생성자 주입, setter 주입, @autowired주입 이 있습니다.

생성자 주입은 객체를 생성할 때 생성자의 파라미터로 의존 객체를 주입함으로써 객체 생성시 필요한 의존 객체의 주입을 강제하는 방법입니다.

setter 주입은 객체를 별개로 생성하고 setter 메소드를 통해 의존 객체를 등록해 주는 것으로써 의존 객체 등록을 강제하지 않아 NPE이 발생할 가능성이 있습니다.

@autowired주입은 의존 객체 필드에 적용하여 자동으로 의존성 주입을 해주는 방법으로 외부에서 등록은 해주지만 개발자가 제어 할수 없게 되어 수정이 필요할때 객체 내부에서 코드를 변경해주어야하며 DI 프레임워크가 있어야 의존성 주입을 할 수 있는 단점이 있습니다.

---



## #3 spring AOP 이란 무엇인가

Aspect Oriented Programming으로 문제를 해결하기 위한 로직을 핵심점관점과 부가적관점으로 나누어 공통 기능을 모듈화하는 것으로써 공통 기능을 모듈화 했기때문에 코드의 중복과 유지보수가 효과적입니다.

---



## #4 spring PSA 이란 무엇인가

Portable Service Abstract로 서비스를 제공하는 기술을 추상화하여 특정 코드를 추가하지 않고 서비스를 이용할 수 있도록 하는 것입니다.

예를 들어 Spring MVC의 @Controller, @RequestMapping 등이 있습니다. 보통 스프링에서 개발자들은 서블릿을 구현하게 되는데 서블릿을 구현하기 위해서는 httpServlet을 상속받아 doGet,doPost와 같은 메소드를 오버라이딩하여 uri에 맞는 요청을 매핑하여 비즈니스 로직을 구현하게 됩니다.

개발할때마다 반복적이고 공통적인 코드 작성을 @Controller나 @RequestMapping을 통해 비즈니스 로직을 구현하기 이전의 과정을 구현한 코드를 추상화 하여 개발자는 비즈니스 로직에만 집중할 수 있도록 해줍니다.

---



## #5 spring mvc life cycle

스프링에서 http요청을 처리하기 위한 프레임워크로써, Model, View, Controller로 구분할 수 있습니다.

1. 요청이 들어오면 dispatcherServlet의 doDispatcher가 호출됩니다.
2. Hanlder매핑을 통해 요청에 맞는 핸들러를 찾아준다.
3. 해당 핸들러를 처리해줄 수 있는 HandlerAdapter를 조회한다.
4. 해당 핸들러 어댑터를 통해 핸들러를 실행하고 핸들러는 결과를 처리하고 ModelAndView를 반환한다.
5. ViewResolver에서 핸들러가 반환한 논리 뷰 주소를 물리 뷰 주소로 변경하여 Model에 들어있는 데이터를 적용합니다.
6. 뷰를 랜더링하여 클라이언트에게 뷰를 보여주게 됩니다.

---



