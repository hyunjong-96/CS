# Network



<br>

-----------------------

### DNS (Domain Name System)

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />




-----------------------

+ IP를 사람이 읽을 수 있는 주소로 변경해주는 시스템
+ www.naver.com
+ domain
  + 인터넷 상에서 사용되는 고유한 이름




</details>

-----------------------

<br>





<br>

-----------------------

### DNS 동작 원리 (도메인으로 IP주소 요청하기)

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />




-----------------------



+ <img width="500" alt="image" src="https://user-images.githubusercontent.com/57162257/195479067-75f55d01-4385-4067-8f12-447b944f689b.png">

1. 사용자는 Local DNS Server에 도메인의 IP주소를 요청한다.
2. Local DNS Server에 IP가 존재하지 않기 때문에 Root Name Server에 해당 도메인 IP를 요청한다.
3. Root Name Server는 해당 도메인의 TLD Name Server IP를 반환한다.
4. TLD Name Server는 해당 도메인의 Authoriative Name Server에 IP를 반환한다.
5. Authoriative Name Server에서 요청 도메인의 IP를 전달한다.
6. Local DNS Server에서 해당 IP를 저장하고 사용자에게 반환한다.
7. 사용자는 IP로 웹서버에 요청하고 응답을 받는다.

- Local DNS Server
  - 통신사에서 제공하는 DNS 서버 (kt, sk 브로드밴드 등..)
- Root Name Server
  - 도메인을 IP로 변환하는 첫번째 단계
  - TLD 네임 서버를 반환
- TLD Name Server (Top Level Doamin)
  - gTLD (generic) 일반 최상위 도메인 : com, net 등을 다룸
  - New gTLD (new generic) 신규 일반 도메인 : cafe, email 등의 도메인을 다룸
  - ccTLD (country code) 국가 코드 최상위 도메인 : kr, co등의 도메인을 다룸
  - Authoriative Name Server를 반환
- Authoriative Name Server
  - 실제 DNS 레코드를 관리하고 있는 서버
  - 마지막 단계로서 도메인의 IP주소를 반환한다.
  - DNS 레코드
    - DNS에 받은 요청을 어떻게 처리할 것인지에 대한 정보
    - A
      - 해당 도메인과 IP 매핑 정보
      - 1 : N 매핑도 가능
      - 장점
        - 도메인이 변경되어도 IP는 유지된다.
      - 단점
        - IP가 변경되면 하나씩 전부 변경해주어야 한다.
    - CNAME
      - 해당 도메인의 별명으로서 별명으로 접근해도 해당 도메인으로 접근이 가능하다.
      - 장점
        - IP가 자주 변경되어도 매핑되어있는 도메인의 IP만 변경해주면된다.
      - 단점
        - 도메인이 변경되면 전부 변경해주어야한다.
        - 여러번 요청시 성능 저히 발생
    - MX (Mail Exchange)
      - 메일 서버 레코드
      - 메일 서버를 확인하는데 사용되며, 해당 도메인에 설정되어있어야 해당 도메인을 이메일로 사용가능하다.
    - NS (Name Server)
      - 네임 서버의 권한을 누가 가지고 있는지 알려주는 레코드
      - 어떤 도메인의 처리를 다른 도메인 네임 서버에 위임하는 가능
      - (도메인을 cafe24에서 구매했다면 해당 도메인의 네임서버는 cafe24)
    - SOA (Start Of Authority)
      - 네임서버가 해당 도메인에 관하여 인증된 데이터를 가지고 있음을 증명하는 레코드
      - SOA 레코드가 없다면 네임서버에서 정상적으로 동작하지 않는다.



</details>

-----------------------

<br>



<br>

-----------------------

### OSI 7계층

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />




-----------------------

+ 통신 접속부터 완료까지의 과정을 7단계로 정의한 국제 통신 표준 규약
+ 7계층으로 나눈 이유
  + 통신이 일어나는 과정을 단계별로 표시하여 흐름을 한눈에 파악하기 위해서이다.
  + 문제가 발생했을때 문제가 발생한 계층을 예상할 수 있고 다른 장비, 소프트웨어를 건들이지 않고 이상이 생긴 단계만 고칠수 있다.
  + 예시
    + PC방에서 컴퓨터를 사용중 프로그램이 사용되지 않는다, 이때 PC모든 컴퓨터가 되지 않는 경우 `1계층(물리 계층)의 케이블` 문제이거나 `3계층(네트워크 계층)의 라우터` 문제일 수도 있다.
      만약 내 컴퓨터만 작동되지 않는다면 `2계층(데이터링크 계층)의 스위치 문제`이거나 `7계층(응용 프로그램)의 사용 프로그램의 소프트웨어` 문제일 수 있다.


1. 물리 계층 (1계층)
   - 데이터를 전송하는 데 필요한 하드웨어 전송 기술을 제공하는 역할
   - 케이블, 허브
2. 데이터 계층 (2계층)
   - 물리계층의 데이터를 네트워크상에 안착시키고 Mac주소로 직접연결된 다른 네트워크 장치로 데이터 전송 담당.
   - Mac주소 : 직접 연결된 네트워크 주소 (IP주소로 이동 경로에 직접 연결된 다음 네트워크 장치의 주소)
   - 브릿지, 스위치
   - 이 계층에서 전송되는 단위를 프레임
3. 네트워크 계층 (3계층)
   - IP를 지정하고 라우터로 경로를 선택해 패킷을 전달하는 계층
   - 호스트간의 논리적 통신
   - IP주소 : 최종 목적지 주소
   - 라우터
   - 이 계층에서 전송되는 단위를 패킷
4. 전송 계층 (4계층)
   - 실질적으로 데이터를 전달하는 계층으로서, 송신측과 수신측간의 패킷 전송을 제어하는 계층
     - 흐름 제어 : 송신측과 수신측 사이의 데이터 처리 속도 차이를 감안해서 데이터 전송을 제어한다.
     - 혼잡 제어 : 네트워크 혼잡을 피하기 위해 데이터의 전송 속도 제어
     - 오류 제어 : 오류 검출과 재전송
   - 응용 프로세스간 논리적 통신
5. 세션 계층 (5계층)
   - 네트워크 상 양쪽 연결을 관리하고 연결을 지속시켜주는 계층
   - 주로 TCP/IP 세션을 만들고 유지하며, 중단됬을때 복구하는 기능이 있다.
   - 통신 연결은 포트 기반으로 구성하여 연결하며, 통신을 위한 세션 확립/유지/종료 과정을 수행한다.
     - 세션 : 일정 기간동안 같은 사용자로 부터 오는 일련의 요구를 하나의 상태로 보고 그 상태를 일정하게 유지하는 기술
   - API, Socket
6. 표현 계층 (6계층)
   - 데이터 압축, 변환이 이루어지는 계층
   - JPEG, MPEG
7. 응용 계층 (7계층)
   - 응용 프로그램과 연관하여 서비스를 수행하는 계층
   - HTTP, DNS



</details>

-----------------------

<br>



<br>

-----------------------

### LAN 통신

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />





-----------------------

- LAN통신은 지역네트워크에서 호스트간의 데이터를 주고받는 과정을 말한다.

- 이때 Routing Table, ARP Table, Mac Table을 통해 송신,수신 호스트 정보를 알고 데이터를 주고받을 수 있다.

- Routing Table과 ARP Table은 모든 PC에 존재하며, Mac Table은 2계층 장비에만 존재한다.

  - Routing Table
    - 목적지 IP로 전달하기 위해 거쳐야할 인접 장비의 IP
    - 다음 이동할 장비또는 LAN의 IP인 next hop IP를 알 수 있다.
    - 만약 Routing Table에 목적 호스트의 IP 즉, next hop IP가 없다면 해당 패킷은 폐기된다.
      - 외부 네트워크에 전달될 routh path가 Routing Table에 등록되어있거나 static하게 정의된 경로가 존재해야한다.
  - ARP Table
    - IP와 Mac을 매핑한 테이블
    - ARP Table에 찾는 IP가 없다면 ARP Request를 통해 IP와 Mac을 저장한다.
  - Mac Table
    - MAC을 사용하는 2계층 장비(스위치)에 존재하는 테이블
    - LAN상에서 각 PC의 Mac주소와 Port를 저장하여 데이터 전송시 목적지 Mac을 통해 해당 Port로 데이터를 전송한다.

- LAN 통신 과정

  <img width="500" alt="image" src="https://user-images.githubusercontent.com/57162257/195513951-0c67559b-493c-4a51-bb16-42635997f62f.png">

  1. PC0에서 통신할 PC1의 IP주소를 알아낸다.
  2. PC0은 Routing Table을 통해 목적 IP로 이동하기 위한 next hop IP를 알아낸다.
  3. ARP Table을 통해 next hop IP의 Mac주소를 확인한다.
  4. ARP Table에 next hop IP가 존재하지 않는다면 ARP Request 메세지를 전송한다.
  5. Switch에서 ARP Request를 수신하고 PC0에 대한 Mac table entry를 만들어준다.
     - PC0의 Mac주소와 송신 port번호를 Mac Table에 기록한다.
  6. Switch는 ARP Request를 LAN Port로 브로드 캐스트한다.
     - ARP 메세지는 LAN 영역 전체로 전송된다.
  7. ARP Request를 수신한 PC1은 자신의 ARP Table에 PC0의 IP와 MAC을 저장하고 자신의 MAC주소를 담은 ARP Reply를 보낸다.
  8. ARP Rely를 수신한 Switch는 PC1에 대한 Mac table entry를 생성하고 PC0에게 전달한다.
  9. ARP Reply를 수신한 PC0은 ARP Table에 PC1의 IP와 MAC을 저장하고 PC1에 전송할 패킷에 목적지 IP와 MAC을 저장해서 송신한다.
  10. Switch는 수신한 패킷의 목적지 Mac주소가 PC1임을 Mac Table을 통해 확인한다.
  11. Mac주소를 확인하고 PC1의 포트로 메시지를 유니캐스트한다.
  12. PC1은 목적지 MAC이 자신임을 확인하고 패킷을 수신하고 IP layer에게 패킷을 전달한다. IP layer에서는 자신의 IP와 동일한것을 확인하고 IP패킷을 수신한다.



</details>

-----------------------

<br>





<br>

-----------------------

### ARP

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />





-----------------------

+ IP
  + 네트워크 계층에서 동작하는 IP프로토콜에서 사용하는 주소 체계로, 데이터를 전달하고자하는 목적지
  + 네트워크 환경에 따라서 변동될수 있다.

+ Mac
  + 데이터링크 계층에서 통신을 위해 네트워크상에 연결되어 있는 장비의 고유 주소
  + 변하지 않는 고유 주소

+ ARP (Address Request Protocol)
  + 단말간 통신에서 IP주소를 이용해 목적지를 지정하지만, 실제 데이터 이동을 위해 Mac주소를 사용해야한다.
  + ARP를 통해 LAN에서 IP와 Mac주소를 매칭하여 목적지를 찾아갈수 있게 해준다.
    - LAN (Local Address Network) : 2계층에서 네트워크 매체를 이용해 가까운 지역을 한데 묶은 컴퓨터 네트워크
      - 또는 ARP Request가 도달하는 영역
    - IP와 MAC을 매칭하여 저장하고 있는 테이블을 ARP 테이블
  + ARP 테이블 생성과정
    1. 송신 호스트가 데이터를 전달하고자 하는 IP의 MAC주소를 찾기 위해 ARP Request를 요청한다.
       - ARP Request는 브로드 캐스트로 요청한다.
         - 네트워크 통신방식
           - 브로드 캐스트
             - UDP기반으로 자신의 호스트가 속해있는 네트워크를 대상으로 패킷을 전송하는 1대N 통신방법
             - MAC주소로 LAN상의 모든 PC에게 요청을 보내고 해당 패킷을 받은 PC는 CPU로 패킷을 처리한다.
             - 트래픽 증가와 CPU성능 저하 발생
           - 유니 캐스트
             - TCP기반으로 하나의 송신자가 다른 하나의 수신자에게 데이터를 전달하는 방식
             - MAC주소를 기반으로 상대측 IP주소를 목적지로 하는 일대일 통신 방식
           - 멀티 캐스트
             - UDP기반으로 네트워크상에서 일부에게만 정보를 전송한다.
             - 유니캐스트시 중복 전송으로 인해 네트워크 효율이 저하되지만 멀티 캐스트를 통해 여러 수신자에게 한번에 메시지 전송이되어 낭비를 줄일 수 있다.
    2. 브로드 캐스트를 받은 PC중 본인의 IP가 아니라면 해당 요청을 버리고 본인의 IP라면 본인의 MAC을 담아 ARP Reply를 보낸다.
       - 이때 수신 호스트도 송신 호스트의 IP와 MAC을 ARP Table에 저장한다.
    3. 목적지의 Mac을 받고 ARP Table에 IP와 Mac을 저장하고 해당 Mac주소로 데이터를 전송한다.




</details>

-----------------------

<br>



<br>

-----------------------

### 라우터

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />





-----------------------

+ 라우터는 전용회선을 통해 LAN에 연결된 컴퓨터들이 인터넷을 사용할 수 있게 해주는 장비
+ 데이터를 목적지까지 전달해주고 2개 이상의 서로 다른 네트워크를 연결하여 데이터를 주고받을 수 있는 중개 기능
+ 라우터의 동작 원리
  + 직접 전달 : 자신의 LAN에 ARP Request하여 데이터를 전달하는 경우
  + 간접 전달 : 다른 라우터에게 ARP Reqeust하여 다른 라우터를 통해 데이터를 전달하는 경우
    + 목적지 라우터로 이동하기 위해서는 목적지 라우터의 route path가 Routing Table에 저장되어있어야한다. 만약 저장되어있지 않다면 해당 패킷은 폐기된다.

+ 라우터 목적지(Router Path) 학습 방법
  + Connected
    + 물리적으로 인접한 장비의 IP주소를 알아와 Routing Table에 저장

  + Static
    + 사용자가 직접 목적지 IP와 next hop IP정보를 입력하는 방식
    + 경로관리에 효율적이지만, 네트워크 변화에 느리다.

  + Dynamic
    + 각 라우터들이 가지고있는 정보를 공유하여 Routing Table에 저장
    + 주기적으로 최적 경로를 계산하여 테이블 정보 유지
    + 네트워크 환경에 빠르게 대처할 수 있지만 주기적 계산으로 CPU사용량이 많아진다




</details>

-----------------------

<br>



<br>

-----------------------

### 네트워크 통신시 수신 호스트가 외부 네트워크에 있다면

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />





-----------------------

- 통신과정

  1. 목적 IP의 Mac주소를 알기 위해 ARP Table도 확인해봤는데 없고, ARP Request를 보냈는데도 없다면, 해당 네트워크에 데이터를 보낼 호스트가 없다.

  2. 송신 호스트는 게이트웨이(Router)에게 ARP Request를 보내어 Router의 Mac주소를 얻고 Router에 데이터를 전송한다.

  3. 라우터는 Routing Table을 통해 수신 호스트 IP를 관리하는 라우터를 찾는다.
     - Routing Table은 ARP를 통해 데이터를 전달할 IP와 Mac을 매칭하여 보낼 라우터의 Mac주소로 보낸다.
     - 마찬가지로 ARP Table에 next hop IP가 없다면 ARP Request를 통해 next hop IP의 MAC주소를 찾아와 저장한다.

  4. 수신 호스트 IP를 관리하는 라우터 자신의 Mac주소를 전달하고 해당 라우터는 Mac주소를 통해 데이터를 전달한다.

  5. 수신 호스트 IP를 관리하는 라우터는 수신 IP는 알지만 Mac주소를 모르기 때문에 다시 ARP Request를 통해 Mac주소를 수신 IP의  Mac주소를 알게되고 해당 Mac주소에 데이터를 전달한다.

  <img width="400" alt="image" src="https://user-images.githubusercontent.com/57162257/195504639-1d8bca30-26db-44cd-a16c-cbfb7ff1c343.png">



</details>

-----------------------

<br>





<br>

-----------------------

### 전송계층

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />




-----------------------

+ 전송계층은 송신자와 수신자에간의 패킷 데이터를 전달하기 위해 TCP 프로토콜과 UDP 프로토콜을 사용한다.
+ TCP (Transmission Control Protocol)
  + 가상회선 패킷 교환 방식으로 처리하는 프로토콜
  + <img width="489" alt="image" src="https://user-images.githubusercontent.com/57162257/185790986-173c2460-8ff8-48a8-83e8-63738c3f8d1c.png">
  + 특징
    + 연결형 서비스로 가상 회선 방식 사용하여 한번만 경로를 지정하고 패킷 순서를 보장
    + 3-way handshaking과정으로 연결을 설정하고, 4-way handshaking을 통해 해제한다.
    + 흐름 제어 및 혼잡 제어
    + UDP보다는 속도가 느리다.
+ UDP (User Datagram Protocol)
  + 패킷을 데이터그램 단위로 처리하는 프로토콜
    + <img width="513" alt="image" src="https://user-images.githubusercontent.com/57162257/185790984-b5c4cb5b-8650-4f50-bd73-7495a05efafb.png">
    + 데이터그램 : 독립적인 관계를 가지는 패킷

  + 특징
    + 비연결형 서비스로 데이터그램 방식을 사용하여 패킷마다 경로를 지정한다.
    + 데이터를 주고받을때 신호절차를 거치지 않는다.
    + 신뢰성이 낮다.
    + TCP보다 속도가 빠르다.




</details>

-----------------------

<br>



<br>

-----------------------

### TCP / IP 4계층

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />




-----------------------

+ 컴퓨터들이 정보를 주고 받는데 사용되는 통신 규약(프로토콜)의 모음
+ OSI 7계층과 같은 역할을 하지만 OSI는 이론적 표준, TCP/IP는 실무적 표준
+ <img width="261" alt="image" src="https://user-images.githubusercontent.com/57162257/185791580-f89957e7-dc52-4630-9ece-6f99bc9f9960.png">

1. 네트워크 연결 계층 (1계층)
   - MAC주소로 직접 연결된 네트워크 장비로 데이터 전송
   - 단위 : 프레임
   - 전송 주소 : MAC
   - 장비 : 브릿지, 스위치
2. 인터넷 계층 (2계층)
   - 데이터 전송을 위한 논리적 주소(IP) 지정 및 경로 지정
   - 단위 : 패킷
   - 전송 주소 : IP
   - 장비 : 라우터
3. 전송 계층 (3계층)
   - 호스트 간의 데이터 송수신 및 연결 제어
   - 단위 : 세그먼트
   - 전송 주소 : Port
4. 응용 계층 (4계층)
   - 응용 프로그램으로 서비스 제공
   - 단위 : 데이터, 메시지



</details>

-----------------------

<br>



<br>

-----------------------

### TCP의 논리적 연결

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />




-----------------------

- 서버는 socket생성 -> socket 주소 할당 -> 연결 요청 대기 -> 연결 허용 -> 데이터 송수신 -> 연결 종료

- 클라이언트는 socket생성 -> 연결 요청 -> 데이터 송수신 -> 연결 종료

- TCP를 이용해 서버와 클라이언트간의 통신을 위해서는 특별한 신호 절차를 거쳐야한다.

- 3 - way handshaking

  - TCP/IP 프로토콜을 이용해 데이터를 전송하기 전에 서로 통신할 준비가 되었는지 확인하는 절차
  - <img width="397" alt="image" src="https://user-images.githubusercontent.com/57162257/185792690-7c95f566-483d-4832-b7c8-05ad1df5e9d1.png">

  1. 클라이언트에서 서버에게 SYN패킷을 보낸다.
     - 이 때 클라이언트는 SYN/ACK 응답을 기다리는 SYN_SEND 상태가 된다.
  2. 서버에서 SYN패킷을 받고 수락하는 SYN/ACK 패킷을 발송한다.
     - 이 때 서버는 ACK를 받기 위해 SYN_RECEIVED 상태가 된다.
  3. 클라이언트는 SYN/ACK 패킷을 받은 후 서버에 ACK패킷을 전송한 후 부터 데이터 통신이 이루어 진다.

- 4 - way handshaking

  - 세션을 종료하기 위해 수행되는 절차
  - <img width="347" alt="image" src="https://user-images.githubusercontent.com/57162257/185792697-47b4ff15-f77c-40c3-84f8-573610ea86b9.png">

  1. 클라이언트가 연결을 종료하겠다는 FIN 패킷 전송
  2. 서버에서 FIN 패킷을 받고 ACK패킷을 보낸 후 자신의 작업이 끝날때 까지 기다린다.
  3. 서버의 작업이 끝나게 되면 연결이 종료되었다는 FIN 패킷을 보낸다.
  4. 클라이언트는 확인했다는 ACK패킷을 보내게된다.

- TCP통신시 TCP헤더에 Seq, Ack Number가 포함되는데
  - Sequence Number
    - TCP 세그먼트의 연속된 데이터번호로서, 전달하는 세그먼트 데이터 번호 중 맨 앞의 번호.
  - Ack Number
    - 다음에 받아야할(요청하는) 세그먼트 데이터 번호



</details>

-----------------------

<br>



<br>

-----------------------

### 4 - way handshaking에서 서버의 통신이 FIN패킷보다 늦게 도착하면 어떻게 되나?

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />




-----------------------

+ 서버의 FIN 패킷보다 서버의 통신이 늦게 도착하게 되면 데이터가 유실되게 된다.
+ 하지만 이를 위해 클라이언트에서 FIN패킷을 받게 되어도 240초 동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거치게된다.



</details>

-----------------------

<br>



<br>

-----------------------

### TCP의 오류 제어, 흐름 제어

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />





-----------------------

+ 흐름 제어 : 송신 측은 수신 측의 데이터 처리 속도를 감안해서 전송할 데이터 크기를 제어한다.
  + Stop and Wait
    + 송신측이 수신측의 확인 응답을 받을 때까지 대기하고 전송하는 방법
  + Sliding Window
    + 수신 측에서 설정한 윈도우 크기만큼 송신 측에서 확인 응답없이 데이터를 연속적으로 전송하는 방법.
    + 송신측은 3wayhandshake를 통해 수신측의 window size에 맞게 송신측의 window size를 맞추고 시작한다.
+ 오류 제어 : 데이터가 유실되었거나 오류가 발생했을때 송신측에서 데이터를 재전송하는것.
  + Stop and Wait
    + 송신측에서 ACK를 기다리다가 타임아웃시 동일한 데이터를 전송하는 방법
    + <img width="323" alt="image" src="https://user-images.githubusercontent.com/57162257/185849036-2eccb373-20c2-43ab-97ad-89a5f15f162d.png">
  + Go back N
    + 송신측에서 여러개의 데이터를 전송한 후 특정 데이터에 대해 수신측에서 NACK를 보내면 해당 데이터부터 다시 요청하는 방법.
    + <img width="310" alt="image" src="https://user-images.githubusercontent.com/57162257/185848913-86968508-7f0b-4891-a3ed-8d64b713adb9.png">
  + Selective Repeat
    + Stop and Wait보다 효율적인 Go back N방식이지만 특정 데이터에 오류가 발생하면 그 이후의 데이터는 폐기처분되어 비효율적일 수 있다.
    + 에러난 데이터에 대해서만 선택적으로 재전송하는 방법
    + <img width="312" alt="image" src="https://user-images.githubusercontent.com/57162257/185849337-e82a6b7b-728d-4277-9d0c-857d494d6030.png">
    + 수신측의 버퍼에 쌓인 데이터가 연속적이지 못하다는 단점
+ 혼잡제어
  + AIMD (Additive Increase / Multicative Decrease)
    + 처음 window size를 1로 선정해놓고 선형적으로 크기를 증가시키는 방법
    + 패킷 전송이 실패했거나 timeout이 발생했다면 패킷 전송 개수를 절반으로 줄인다.
    + 장점
      + 네트워크를 공평하게 사용할수 있다
    + 단점
      + 초기에는 네트워크의 넓은 대역폭을 사용하지 못한다
  + Slow Start
    - AIMD의 초기 window size가 작다는 문제를 해결하기 위해, 초기 window size를 1로 선언하고 지수적으로 증가시키는 방법
    - 혼잡이 감지되면 window size를 1로 줄이는 방법
    - 혼잡 제어가 발생했다면 발생한 지점의 절반까지만 window size를 지수적으로 증가시키고 이후 부터는 선형적으로 증가시키는 방법
  + Fast Retransmit
    + TCP에서 패킷을 성공적으로 받았다면 다음 seq번호를 ACK에 담아서 요청하게 되는데, 중간에 하나의 데이터가 중복해서 송신자에게 ACK를 보내게 된다면 해당 패킷에 대해 오류 제어를 수행하고 혼잡 상황임을 감지하고 window size를 줄이게 된다.
    + time out이 발생하기 전에 오류제어를 수행함으로써 시간 낭비를 줄일 수 있다.
  + Fast Recovery
    + 혼잡 상황에서 window size를 1로 줄이지않고 반으로 줄여 window size를 선형증가하는 방법
    + 이 정책을 적용하면 빠르게 window size를 복구할 수 있다.





</details>

-----------------------

<br>



<br>

-----------------------

### www.naver.com 검색시 발생하는 과정

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />




-----------------------

1. www.naver.com을 브라우저 주소창이 입력한다.
2. 브라우저는 local DNS을 확인하여 www.naver.com에 대한 IP정보가 있는지 확인한다.
3. 요청한 도메인이 존재하지 않는다면 도메인을 호스팅하고 있는 서버의 IP 주소를 찾기 위해 Recursive Query를 한다.
4. 브라우저는 도메인의 IP를 받아 서버와 TCP연결을 한다 (3-way handshaking)
   1. 브라우저는 서버에 접속 요청 SYN패킷을 보낸다.
   2. 서버는 수락하는 SYN/ACK 패킷을 보낸다.
   3. 클라이언트는 확인 ACK패킷을 보낸다.
5. TCP연결이 완료되면 브라우저가 웹 서버에 HTTP 요청을 보낸다.
6. 서버는 요청을 처리하고 response를 생성한다.
7. 브라우저가 HTML을 사용자에게 보여준다.



</details>

-----------------------

<br>



<br>

-----------------------

### HTTP & HTTPS

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />




-----------------------

+ HTTP(Hyper Text Transfer Protocol)
  + www상에서 클라이언트와 서버 사이에서 이루어지는 요청을 처리하는 프로토콜
  + 상태를 가지지않고(stateless) 비연결지향(connectionless)이다.
    + 요청과 응답이 끝나면 연결이 끝나고 연결이 끝나게 되면 클라이언트와 서버간의 상태를 유지하지 않는다.
  + HTTP는 TCP기반의 통신방법이며 단기적으로 Connection하는 TCP라 볼수 있다. TCP기반이기 때문에 Handshake과정이 필요하다.
  
+ HTTPS(Hyper Text Transfer Secure)
  + HTTP에 보안이 추가된 프로토콜로 데이터를 제3자가 볼수 없도록 암호화하여 신뢰성 있는 요청을 하기 위함
  
  + SSL/TLS라는 다른 프로토콜 조합을 통해 HTTP의 통신 내용을 암호화 하는것
    즉, SSL을 조합한 HTTP를 HTTPS
  
  + HTTP 메세지 전체를 암호화하는것이 아닌 HTTP Body만 암호화하는 것
  
  + TLS / SSL
  
    + SSL (Secure Sockets Layer)
      + 브라우저와 서버 사이에 전송되는 데이터를 암호화하여 인터넷 연결을 보호하기 위한 표준 기술
    + TLS (Transport Layer Security)
      + SSL의 최신화 버전으로 SSL은 비활성화되었지만 SSL이 익숙한 용어이기 때문에 SSL/TSL이라고 공통으로 불러서 사용한다.
    + 응용계층과 전송계층 사이에서 동작한다.
  
  + 암호화
  
    + 대칭키 암호화
      + 클라이언트와 서버가 동일한 키를 사용해 암호화/복호화를 진행함
      + 키가 노출되면 위험하지만 연산 속도가 빠르다
    + 비대칭키 암호화
      + 1개의 쌍으로 구성된 공개키와 개인키를 암호화/복호화 하는데 사용함
      + 키가 노출되어도 비교적 안전하지만 연산 속도가 느림
      + 공개키 암호화
        + 공개키로 암호화, 개인키로 복호화
        + 개인키로 복호화할 수 있기 때문에 나만 볼 수 있다.
      + 개인키 암호화
        + 개인키로 암호화, 공개키로 복호화
        + 공개키는 모두에게 공개되어있으므로, 내가 인증한 정보임을 알려 신뢰성을 보장할 수 있다. (전자서명)
  
  + SSL 인증서
  
    + HTTPS를 이용하여 클라이언트와 서버의 통신을 제 3자인 CA가 보장하는 전자 문서
      + CA (Certificate Authority)
    + 용도
      + 대칭키를 암호화하기위한 공개키를 클라이언트에게 제공
      + 클라이언트가 사용하는 서버가 신뢰할 수 있음을 보장
  
  + HTTPS 동작과정
  
    + HTTPS는 연결과정(handshake)에서 클라이언트와 서버간 세션키를 공유한다.
      + 세션키는 데이터를 암호화/복호화 하기 위한 대칭키로, 데이터 교환간에 빠른 연산을 위해 대칭키를 사용한다.
    + 이때 처음 연결에 성공하여 안전하게 세션키를 공유하는 과정에서 비대칭키가 사용된다.
  
    1. 클라이언트가 서버에 웹 서버에 접속 시도하면서 3-way handshake를 수행하고 https를 사용하는것을 알고 서버에게 SSL버전 정보와 지원하는 암호화 방식(cipher suite), 난수를 포함하여 전달.
       - 이전에 SSL handshake를 했었다면 세션키를 전달한다.
    2. 서버는 전달받은 암호화 방식과 서버측에서 생성한 난수, 인증서(공개키)를 클라이언트에게 전달.
    3. 클라이언트는 인증서의 유효성 검사를 한 후 클라이언트에서 생성한 난수와 서버에서 생성한 난수를 조합하여 pre master key발급.
    4. 클라이언트는 pre master key를 인증서에서 얻은 공개키로 암호화하여 서버에 전달.
    5. 서버는 개인키로 암호화된 pre master key를 복호화하고 일련의 과정을 거쳐 master key로 변경하고 master key를 통해 세션키를 생성한다.
    6. 클라이언트와 서버는 세션키를 공유하여 데이터 교환간에 세션키를 이용해 암호화/복호화를 수행한다.
  
  + HTTPS 발급과정
  
    1. A기업은 HTTPS를 적용하기 위해 공개키,개인키를 발급한다.
  
    2. CA기업에 돈을 지불하고 인증서 발급을 요청한다.
  
    3. CA기업은 CA기업 정보, A기업의 공개키를 기반으로 인증서를 발급하고 CA기업의 개인키로 암호화한다.
  
    4. CA기업의 인증서를 받은 A기업은 클라이언트에게 공개키를 제공한다.
    5. 클라이언트는 미리 CA기업의 공개키를 다운받고, 인증서를 복호화하여 A기업의 공개키를 얻는다.
    6. 클라이언트는 세션키를 공개키로 암호화하여 서버에 전달하고 서버는 개인키를 통해 세션키를 복호화하여 세션키를 공유한다.
  
+ HTTP와 HTTPS

  + HTTP는 암호화가 추가되지 않아 보안에 취약하지만, HTTPS는 안전하게 데이터를 주고받을 수 있다. 하지만 암호화/복호화 과정이 필요하여 HTTP보다 속도가 느리고 인증서를 발급하고 유지하기 위한 추가 비용이 발생한다.






</details>

-----------------------

<br>



<br>

-----------------------

### Cipher suite

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />





-----------------------

+ Https handshake과정에서 client와 server가 어떤 방식으로 암호화를 진행할 것인지 정하는 암호 집합소
+ 보안의 궁극적 목표를 달성하기 위해 사용하는 방식을 패키지 형태로 묶어놓은 것
+ `[프로토콜] _ [키 교환방식] _ [인증서 검증] _ WITH _ [대칭키 블럭 암호화 방식] _ [블럭 암호 운영 방식] _ [메시지 인증]`
+ 프로토콜
  + SSL/TSL 프로토콜의 버전

+ 키 교환 방식 (키 교환 알고리즘)
  + 클라이언트와 서버간 데이터를 암/복호화 할 수 있는 대칭키(세션키)를 전달하기 위한 방법
  + 공개키 암호화 방식
  + 종류
    + RSA : 소인수 분해 문제에 기반을 둔 알고리즘
      + PFS를 제공하지 않기 때문에 주로 사용되지 않는다
        + PFS : 비밀키가 제 3자에게 노출되면 과저의 모든 암호화된 데이터를 해독해버릴수 있기 때문에 기존 암호문을 노출된 비밀키로 해독할 수 없도록하여 과거의 데이터의 보안성 보장 해주는 방법. (세션키의 수명을 짧게 유지)
        + DH단계에서 도출되는 키를 암호화 작업이 끝나면 파기시키고 필요할 때 다시 새로운 키를 만드는 특성

    + DSA : 이산 대수 문제의 어려움을 이용한 알고리즘
    + ECC : 타원곡선 암호방식
      + RSA나 DSA보다 짧은 키를 사용하면서 비슷한 수준의 안전성을 제공한다는 장점

    + DH(디프 헬만)
      + DHE
      + ECDHE : 기존 RSA나 DH에 비해 적은 bit로 비슷한 수준의 보안성 제공

+ 인증서 검증
  + CA가 발급한 SSL 인증서를 검증하기 위한 알고리즘
  + SSL인증서를 CA의 공개키로 복호화하는 과정.
  + 개인키 암호화 방식

+ 대칭키 블록 암호화 방식
  + 실제 전송되는 메세지를 암호화 하는데 사용
  + 대칭키 암호화 방식
  + 암호화에 사용되는 대칭키(세션키)가 길어질수록 암호화의 강도가 강해지고 암/복호화에 사용되는 리소스 소모가 커진다.

+ 블록 암호 운영 방식
  + 데이터를 암호화 할때 한꺼번에 암호화하는 것이 아닌, 블록 단위로 암호화 하게 되는데, 블록으로 구성된 암호 패킷을 조합하여 데이터를 추측하는것을 방지하기 위한 방식
  + 대칭키 암호화 방식

+ 메시지 인증
  + 서로 상대방이 암호화 한것이 맞는지 확인하기 위한 알고리즘
  + 데이터 무결성
  + RSA 알고리즘
    + 대칭키 알고리즘

  + SHA 알고리즘
    + 일방향
      + 해시 알고리즘이 적용된 결과값에서 원본 메시지로 되돌릴수 없다는 특성이 있다.

    + 암호화된 데이터를 주고받더라도 이 데이터가 정말로 누군가에게 의해 조작되어 변했는지, 변하지 않았는지 알수없다. 이를 확인하기 위해 특정 알고리즘을 사용해 원본 데이터를 일정한 길이의 암호화된 문자열로 변경한다.
      이 특정 알고리즘은 원본 데이터마다 일정한 결괏값을 도출하며 원본 데이터가 변경되면 결괏값 또한 달라지는 특성이 있다.
    + 송신자는 원본 데이터(암호화 알고리즘에 의해 암호화된 데이터)와 해시 알고리즘이 적용된 데이터를 함께 전송하고, 수신자는 약속한 해시 알고리즘을 이용해 원본 데이터에 적용해본다. 송신자가 보낸 해시 알고리즘이 적용된 데이터와 약속된 해시 알고리즘을 적용한 원본데이터를 비교하고 결과가 같다면 변조되지 않은 메시지.




</details>

-----------------------

<br>



<br>

-----------------------

### Http status code

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />




-----------------------

+ 1xx
  + 요청이 수신되어 처리중

+ 2xx (Successful) : 요청 정상 처리
  + 200 (OK) : 요청 성공
  + 201 (Created) : 새로운 리소스 생성 성공
  + 202 (Accepted) : 요청을 받았으나 처리가 완료되지 않음
  + 204 (No Content) : 요청을 수행했지만, 응답할 데이터가 없음

+ 3xx (Redirection) : 요청을 완료하고 다음 추가 행동 필요
  + Redirection : location 헤더가 있다면 location 위치로 이동하는 것

+ 4xx (Client Error) : 클라이언트 측에서 잘못된 데이터 요청
  + 400 (Bad Request) : 클라이언트의 잘못된 요청으로 처리할 수 없음
  + 401 (UnAuthorized) : 인증 필요
  + 403 (Forbiddent) : 사용 권한 필요
  + 404 (Not Found) : 요청한 리소스가 없음

+ 5xx (Server Error) : 서버 오류
  + 500 (Internal Server Error) : 서버가 처리 방법을 모르는 오류
  + 502 (Bad Gateway) : 서버가 잘못된 응답을 수신
  + 503 (Service Unavailable) : 서버가 요청 처리 준비가 안됨
  + 505 (Http version not support) : 해당 http 버전 지원하지 않음
  
+ 요청시 400이 발생하게 되면 동일한 데이터를 재전송을 하여도 문제를 처리할 수 없다.
+ 요청시 500이 발생하게 되면 서버에서 처리를 완료하고 요청을 보내면 문제를 처리할 수 있다.



</details>

-----------------------

<br>



<br>

-----------------------

### Http method

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />





-----------------------

+ Http를 통해 요청한 자원을 어떻게 처리할것인지 정의
+ 종류
  + Get : 조회
    + 전달하고자하는 데이터는 query를 통해 전달
    + body로 데이터를 전달할 수는 있지만, 권장하지 않는다.

  + Post : 추가
  + Put : 수정, 존재하지 않는다면 추가
  + Patch : 리소스 일부만 변경
  + Delete 삭제
  + Options : 대상 리소스에 대한 통신 가능 옵션 설명
    + CORS에서 주로 사용

+ 속성
  + 안전
    + 메소드를 호출해도 리소스를 변경시키지 않는다.
    + Get, Options

  + 멱등
    + 특정 HTTP메서드를 여러 번 요청했을때, 매번 요청 결과가 같은 것.
    + GET : 여러번 수행해도 서버의 상태가 변하지 않고 같은 결과를 가져온다.
    + PUT : 여러번 수행해도 데이터는 요청한 값으로 수정된 같은 상태이다.
    + DELTE : 여러번 수행해도 그 데이터는 요청을 보낸 시점에 사라진다.
    + POST : 여러번 수행하면 부가적인 결과를 가져온다. (같은 데이터 계속 추가)

  + 캐시가능
    + 리소스를 캐싱해놓고 method 요청시 효율적으로 사용하는것
    + 이미지와 같은 리소스를 캐시해놓는다.
    + Get,Post,Patch에서 캐시가 가능하지만 Get에서 주로 사용




</details>

-----------------------

<br>



<br>

-----------------------

### http1.0 & http1.1

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />




-----------------------

+ http 1.0
  + connection 하나당 하나의 요청을 처리할 수 있다. 그렇기 때문에 응답을 받아야 다음 요청을 진행 할 수 있다.

+ http 1.1
  + keep alive를 통해 connection 하나당 N개의 요청을 처리할 수 있다.
    + 특정 시간까지 access가 오지 않더라도 연결을 끊지않고 유지하는 헤더
  + 응답이 오지않아도 연속적으로 요청을 보낸다. (파이프 라이닝)
  + http 1.0은 하나의 ip당 하나의 도메인 운영이 가능. http 1.1은 여러 ip로 하나의 도메인 운영이 가능하다.

<img width="421" alt="image" src="https://user-images.githubusercontent.com/57162257/185845135-53c5ddc8-231b-4c2c-9c19-2df4501c8099.png">

- 단점
  - 파이프 라이닝을 통해 순차적인 여러 요청을 연속적으로 보내고 그 순서에 맞춰 응답을 받는 방식으로 지연 시간을 줄였다. 하지만 순차적으로 데이터 요청을 받아야 하다보니 먼저 받은 요청이 끝나지 않으면 그 뒤의 요청이 빨리 끝나도 앞의 요청처리가 끝날때 까지 기다려야하는 `HTTP의 HOL(Head Of Line) Blocking` 발생
  - http/1.1의 헤더에는 많은 메타데이터가 저장되어져있는데 요청마다 중복되는 헤더를 요청하게 된다.



</details>

-----------------------

<br>



<br>

-----------------------

### http2.0

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />




-----------------------

+ <img width="500" alt="image" src="https://user-images.githubusercontent.com/57162257/193278022-d8dbe674-2b72-43c7-8bb8-f43055d54e19.png">
  + 한 connection에서 동시에 여러개의 메시지를 주고받을 수 있으며, 응답은 순서에 상관없이 stream으로 주고받게됨.
+ Multiplexd Stream
  + <img width="965" alt="image" src="https://user-images.githubusercontent.com/57162257/185845962-4b009599-2c65-451a-a7ba-2284bfd704f8.png">
  + Connection당 여러개의 메시지를 주고 받을 수 있게 메시지를 Stream으로 주고 받는다.
    + Stream : 클라이언트와 서버사이에 맺어진 연결을 통해 양방향으로 주고받는 하나 혹은 복수개의 Message
    + Message : 요청, 응답 단위로서 다수의 Frame으로 이루어짐
    + Frame : Http/2 통신상 최소 정보단위로, Header와 Data로 이루어짐
+ Stream Prioritization
  + 렌더링 지연 등 을 예방하기 위해 Stream으로 전달시 리소스 간의 의존관계에 따른 우선순위를 적용한다.
+ Server Push
  + <img width="750" alt="image" src="https://user-images.githubusercontent.com/57162257/185845983-276ac35c-c95d-47aa-a20c-aa52343e43d5.png">
  + 서버는 클라이언트에서 요청하지 않은 리소스도 보낼 수 있다.
  + http 1.1에서는 HTML을 요청했을때 그 안에 css, img가 있었다면 재 요청을 했다. 하지만 http 2.0에서는 HTML요청시 안에 css, img가 있다면 HTML문서에 포함된 리소스도 Push해서 반환해준다.
+ Header Compresion
  + <img width="700" alt="image" src="https://user-images.githubusercontent.com/57162257/185846030-7acce1d7-b2eb-4d91-bd61-5ea4272a2418.png">
  + Header에서 중복되는 내용이나 필드를 재전송하지 않아서 데이터를 절약한다.
  + http 2.0 이전에는 Header가 평문이였지만 http 2.0에서는 HashTable과 HPACK 헤더 압축 방식을 사용해서 데이터를 효율적으로 전송한다.




</details>

-----------------------

<br>



<br>

-----------------------

### 세션, 쿠키, JWT

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />




-----------------------

+ HTTP는 connection less, stateless 의 특성을 가지기 때문에 서버는 클라이언트가 누구인지 매번 확인해야한다.
+ 쿠키
  + 사용자의 정보를 사용자 컴퓨터에 저장하는 작은 기록 파일.
  + 쿠키의 만료시간이 지날때까지 유지된다.
  + 장점
    + 클라이언트의 정보를 사용자가 가지고 있어 서버에 부담이 줄어든다.
  + 단점
    + 클라이언트의 컴퓨터에 저장되어있기때문에 변질될 수 있다.
+ 세션
  + 일정 시간동안 같은 브라우저로부터 들어오는 일련의 요구를 하나의 상태로 보고 그 상태를 유지하는것.
  + 서버에 사용자의 정보를 저장한다.
  + 브라우저 종료시 삭제된다.
  + 장점
    + 클라이언트는 session id만 가지고 사용자 정보는 서버에서 처리하기 때문에 쿠키보다 보안성이 좋다
  + 단점
    + 별도의 저장공간이 필요하다
    + 사용자가 많아질수록 저장공간을 많이 차지한다.
    + 캐시나 메모리를 사용해서 세션을 유지할 경우, 분리된 서버에서는 해당 서버에만 요청할수있도록 구성해야한다.
  + Session Id만 가지고 서버에서 정보를 처리하기 때문에 쿠키보다 보안성이 좋다.
+ 세션보다 쿠키를 더 많이 사용하는 이유
  + 사용자의 요청이 많게 되면 사용자 정보를 저장하는 서버에서 부담이되기 때문에 쿠키를 사용한다.
+ JWT
  + JWT는 토큰을 만들어 발행하는 방식
  + 탈취가능성이 있기 때문에 JWT의 유효기간을 짧게 가지고 Refresh토큰을 이용해 새 토큰을 받게 한다.
  + 장점
    + JWT가 자체적으로 사용자 정보를 가지고 있기 때문에 별도의 저장공간이 필요하지 않고 분리된 서버에서도 사용자 인증이 가능하다.
    + JWT를 통해 서버에 요청하면 유효한 토큰 여부만 검증하면 된다.
  + 단점
    + JWT의 크기가 커질수록 트래픽에 영향을 미칠 수 있다.
    + JWT의 사용자 정보와 DB사용자 정보가 불일치 할 수 있다.
    + 토큰을 강제로 만료시킬 수 없다.
  + 구성
    + Header
      + 알고리즘 방식
      + 타입
    + Payload
      + 사용자정보
      + 유효시간
    + Signe
      + 해시 알고리즘을 통해 payload를 암호화한 방식
      + 클라이언트에게 받은 JWT의 payload가 변질되었는지 확인하는데 사용
      + 종류
        + HS
          + SHA를 이용한 암호화 방식으로, 서버에서 원본데이터를 해싱하고 암호화 하는 방법
          + 대칭키를 사용하기 때문에 사용자를 제어할 수 있는 경우에만 사용한다.
          + JWT에서는 변조여부를 서버에서만 확인하면 되기 때문에 비밀키를 서버에서 소지하고 유효검사를하기 때문에 HS를 안전하게 사용가능하다.
        + RS
          + SHA를 이용한 비대칭키 암호화 방식으로, 메세지를 해싱한 뒤 private키로 암호화하고 public키로 복호화하는 방법
          + 비대칭키를 사용하기 때문에 사용자를 제어할 수 없는 경우에만 사용한다.
  + 과정
    1. 사용자 인증을 완료하고 노출되어도 상관없는 정보를 JSON형태로 만든다. (payload)
    2. JSON형태의 payload를 base64로 인코딩해서 문자열을 만들고, 시스템의 비밀키를 이용하여 서명 문자열을 생성한다.
    3. Header, Payload, 서명문자열을 하나로 합친 후 클라이언트에게 전송
    4. 클라이언트는 서버로받은 토큰을 클라이언트 저장공간에 저장한다.
    5. 클라이언트는 매번 요청시 이 토큰을 서버에 전달
    6. 서버는 JWT의 토큰을 디코딩하여 토큰의 유효성검사(유효시간, 서명을 통해 변조 여부 확인)후, payload에 있는 사용자 정보를 사용한다.





</details>

-----------------------

<br>



<br>

-----------------------

### OAuth

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />




-----------------------

+ 외부 인증 프로그램에게 해당 서비스의 사용 권한 부여를 위임하는 수단.
+ 인증 (authentication) : 사용자 신원 확인
+ 인가 (authorization) : 기능 접근 권한 확인



</details>

-----------------------

<br>



<br>

-----------------------

### URI & URL & URN

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />




-----------------------

+ URI (Uniform Resource Identifier)
  + 인터넷상의 특정 자원을 나타내는 유일한 주소
  + comic.naver.com/webtoon/detail ? titleId=1234&no=100&weekday=sat
  
+ URL (Uniform Resource Locator)
  + 웹에서 존재하는 자원의 위치
  + 특정 자원을 어떻게 가져와야하는지 명시하는 것.
  + comic.naver.com/webtoon/123123.JEPG

+ URN (Uniform Resource Name)
  + 특정 자원에 대해서 위치에 영향을 받지 않는 유일한 이름 역할
  + 리소스의 위치를 옮기게 되어도 해당 자원을 가져오는데 영향을 받지 않음.




</details>

-----------------------

<br>



<br>

-----------------------

### REST API

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />




-----------------------

+ REST
  + URI를 통해 자원을 명시하고 HTTP 메소드를 통해 자원을 처리하도록 설계된 아키텍처
  + 장점
    + HTTP 프로토콜을 그대로 사용하기 때문에 REST API설계시 추가적인 인프라없이 사용할 수 있다.
    + 서버와 클라이언트의 역할을 명확히 구분할 수 있다.
  + 단점
    + 사용할 수 있는 메소드가 제한적이다.
    + 표준규약이 없다 (안티 패턴을 판단하는 것은 암묵적 규칙에 의한 것)
  + 필요성
    + 다양한 플랫폼(브라우저, 모바일) 지원을 위한 아키텍처가 필요했고 명확한 이용 방법이 필요했기 때문에 REST를 선택
+ REST API
  + REST 기반으로 만들어진 API
+ REST ful
  + REST 아키텍처와 규칙에 따라 구현한 시스템
+ REST 규칙
  1. 후행 슬래시(/) 금지
     - test.com/board/
  2. 계층 관계시 슬래시(/) 사용
     - test.com/board/13
  3. URI 가독성을 위한 하이픈(-) 사용
     - test.com/board/my-first-board
  4. URI 작성시 소문자
  5. 확장자는 URI에 포함하지 않는다.
     - content-type에 미디어 유형을 넣어 본문 컨텐츠 처리
  6. 단어 사용시 복수형
  7. 단어 사용시 동사보단 명사



</details>

-----------------------

<br>



<br>

-----------------------

### CORS (Cross Origin Resource Sharing)

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />




-----------------------

+ cors는 교차 출처 리소스 공유로, 다른 출처의 URL을 요청하여 리소스를 가져오는 것을 말한다.
+ 목적
  + 악용 도메인이 다른 도메인(네이버, 카카오)의 URL정보를 가져와 사용자의 웹 브라우저에 올리는 거나 서버에 악의적인 요청을 보내는것을 SOP를 이용하여 브라우저에 막기 위함.
    + SOP (Same Origin Policy)
      + 허용된 출처에서만 리소스를 사용할 수 있도록 하는 정책
+ 방법
  + 다른 도메인에서 요청을 보낼때 http header의 origin 속성에 출처의 protocol(http, https) + host + port를 작성하고 요청받는 서버에서 다른 도메인 (출처)으로 부터 온 요청을 허용하는 출처를 http header의 Access Control Allow Origin에 미리 명시하여 웹 브라우저가 origin과 Access Control Allow Origin과 비교하여 허용 여부를 판단한다.
+ 종류
  + Simple Request
    + <img width="794" alt="image" src="https://user-images.githubusercontent.com/57162257/186048998-ffaf6627-4128-4d71-abc5-822732025f0d.png">
    + 실제 http header origin에 출처의 정보를 넣고 서버에서 응답할때 Access Control Allow Origin에 CORS를 허용하는 출처를 보내 동일한 출저일때만  허용한다.
    + 서버는 요청을 수행하고 CORS여부는 브라우저에서 판단하기 때문에 서버 데이터에 영향을 미치지 않는 GET에 사용한다.

  + Prefilght Request
    + <img width="790" alt="image" src="https://user-images.githubusercontent.com/57162257/186048955-f7a13eae-eaa6-4bc2-adf9-75bddb4c33c1.png">
    + 실제 요청전  Prefilght라는 요청을 보내 Origin과 Access Control Allow Origin과 비교하여 허용된 출처인지 확인하고 실제 요청을 하게 하는 방법
    + 서버 데이터에 영향을 받을 수 있는 PUT, DELETE에 사용된다.




</details>

-----------------------

<br>



<br>

-----------------------

### CORS & CSRF & XSS

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />







-----------------------

- CORS (Cross Origin resource sharing)
  - 교차 출처 리소스 공유
  - 다른 출처(domain)로 URL을 요청하여 리소스를 가져오는 것.
  - 서버에서는 응답시 access-control-allow-origin에 허용된 도메인을 보내고 사용자의 웹 브라우저는 요청때 보낸 origin에서 출처의 도메인과 비교한다.

- CSRF (Cross Site Request Forgery)
  - 사이트간 위조 요청
  - 로그인된 사용자가 메일이나 링크를 누르게 되면 Put, Delete로 서버에 악의 요청을 보내는 것.
    - 주로 권한을 부여받은 권한자를 타겟으로 이루어진다.
  - 서버에서는 요청 헤더의 referer에 등록되어 있는 요청 domain정보를 확인하여 올바른 domain에서 요청이 들어왔는지 확인하거나,
    Csrf-token을 사용해서 사용자가 요청시 csrf-token이 올바른지 판단하여 검증하는 방법
    - 서버에서 생성된 곳에서 요청을 보내고있음을 증명한다.(referer, csrf-token)
    - CSRF-token ex) 정상적인 경로에서의 submit에 hidden으로 csrf-token을 숨겨놓고 요청시 함께 보냄)
  
- XSS (Cross Site Scripting)
  - 공격자가 상대방이 자주사용하는 웹사이트에 악성 스크립트를 삽입하여 사용자가 악성 스크립트가 포함된 게시글을 사용했을 때 공격자에게 사용자의 쿠키 정보를 탈취하여 사용자 정보를 도용하거나 해당 사이트에 악의적 요청을 보내는것.
  - 사용하고 있는 웹 사이트 이상한 점은 없는지 이상한 URL로 접속해있는지 확인해야한다.

</details>

-----------------------

<br>



<br>

-----------------------

### 중간자 공격

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />




-----------------------

+ 데이터를 송수신 할때 제 3자가 데이터를 탈취하는 것.
+ 종류
  + 스피닝
    + 전송 중인 데이터 패킷을 캡처

  + 패킷 주입
    + 공격자가 일반 데이터 패킷에 악의적인 데이터 주입

  + 세션 하이재킹
    + 사용자의 연결 상태를 가로채는 것

  + 보안 소켓 계층 스트리핑
    + SSL 연결을 차단하여 HTTPS를 HTTP로 변경하는 것.




</details>

-----------------------

<br>



<br>

-----------------------

### 포트와 소켓

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />





-----------------------

+ 포트
  + 네트워크를 통해 데이터를 주고 받는 통신 프로세스를 식별하기 위해 프로세스가 할당받는 고유한 값
  + 하나의 IP주소에서 통신 프로세스의 식별 값
  + 예시
    + 컴퓨터에 카카오, 슬랙, 라인 등의 메시지 프로세스가 실행중일때, 아무런 정보없이 컴퓨터에 메세지가 도착하게 되면 어떤 프로세스가 메세지를 처리할지 모르게 된다. 그렇기 때문에 메세지(통신) 프로세스 별로 port를 할당하여 메세지를 보낼때 메세지를 처리할 통신 프로세스의 port를 추가해서 보내주면 해당 통신 프로세스가 메세지를 처리해주게 된다.
  + 종류
    + port에는 규약처럼 사용되는 것들이 있는데, HTTP통신 80포트, HTTPS통신 443포트
+ 소켓
  + <img width="300" alt="image" src="https://user-images.githubusercontent.com/57162257/195763421-5d74c289-261a-4a4d-80af-36af7f415aeb.png">
  + 네트워크상에서 프로세스간 통신의 종착점에서 데이터를 주고 받는 통신방법
  + 프로토콜 (http) + IP + Port로 정의할 수 있다.
  + 한번의 연결로 연속적으로 메세지를 주고받을 수 있다.
  + 소켓 통신
    + 서버 : 소켓 생성 -> 소켓 주소 할당 -> 연결 요청 대기 -> 연결 허용 -> 요청 응답 -> 종료
    + 클라이언트 : 소켓 생성 -> 연결 요청 -> 요청 -> 종료
  + 종류
    + TCP : 스트림
    + UDP : 데이터그램




</details>

-----------------------

<br>



<br>

-----------------------

### WebSocket과 Socket.IO

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />




-----------------------

+ 웹 브라우저에서는 HTTP Protocol을 사용하기 때문에 한번의 요청이 오면 응답을 보내는 비연결형 단방향 구조로 통신한다.

+ 그렇기 때문에 웹 브라우저에서 TCP/IP 프로토콜을 사용하는 Socket처럼 connection이 유지되지 않아 실시간 통신이 불가능하다.

+ 웹 브라우저에서 실시간 통신을 지원하는 기술이 WebSocket

+ 장점

  + 비연결형인 HTTP Protocol에서도 실시간 통신이 가능하다.

+ 단점

  + HTML5 이전의 기술에서는 사용이 어렵거나 제한된다.
  + 서버와 클라이언트간의 소켓 연결자체가 CPU에 부담이 된다.

+ 동작

  1. 핸드 쉐이킹

     <img width="531" alt="image" src="https://user-images.githubusercontent.com/57162257/185889580-208d52a2-a949-4ce2-9e03-e1857bc49788.png">

     1. 브라우저와 서버를 연결하기 위해 브라우저에서 HTTP Uprade Header를 사용하여 HTTP Protocol을 WebSocket Protocol로 변경하여 웹 소켓 통신이 시작된다.

  2. 데이터 전송
     - 프레임이라는 데이터를 사용하여 메시지를 전송한다.
     - 종류
       - 텍스트 프레임
       - 바이너리 데이터 프레임

  3. 연결 종료
     - 연결 종료를 원하는 측에서 종료 프레임을 전송하면 연결이 종료된다.

+ Socket.io

  + HTML 5 이전 기술에도 WebSocket을 적용하기 위해 만들어진 라이브러리
  + WebSocket을 지원하는 브라우저에는 WebSocket으로 동작하고, 지원하지 않는 브라우저에는 HTTP Protocol을 이용해 실시간 통신을 흉내낸다.




</details>

-----------------------

<br>



<br>

-----------------------

### 로드 밸런싱

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />




-----------------------

+ Scale up, Scale out

  + Scale up : CPU나 RAM을 교체하여 서버의 성능 자체를 업그레이드하는 방법
    + 서버 한대로 많은 요청을 처리한다.

  + Scale out : 비슷하거나 낮은 성능의 서버를 여러대 증설하는 방법
    + 여러 서버로 요청을 처리한다.
    + 트래픽을 균등하게 분산시키기 위해 로드 밸런싱이 필요하다.

+ 로드 밸런싱이란, 서버에 가해지는 부하 (Load)를 분산 (Balancing)해주는 기술

+ Load Balancer의 서버 선정 기준
  + Round Robine (라운드 로빈)
    + 요청을 순서대로 돌아가며 서버에 배정하는 방식
    + 서버와의 연결이 오래 지속되지 않는 경우 적합
  + Least Connection
    + 연결 개수가 가장 적은 서버 선택 (가장 많이 사용)
  + 해시 방식
    + 사용자의 IP를 해시함수로 매핑하여 특정 서버만 선택
    + 세션을 유지해야하는 서버에서 사용
  + 가중 라운드 로빈
    + 서버의 성능에 따라 가중치를 정하고, 해당 가중치 만큼 세션을 맺어주는 방식
  
+ 방법

  + 소프트웨어

    - ReverseProxy
      - 클라이언트에서 서버로 요청이 오게되면 요청을 대신 받고 특정 서버에 요청을 전달하는 서버
      - NginX, HaProxy등이 있다.
      - NginX, HaProxy는 로드밸런싱만을 위한 소프트웨어가 아니기 때문에 기본적인 로드밸런싱 기능만 있지만, 그만큼 저렴하고 구축이 쉽다.
      - 장점
        - 보안
          - ReverseProxy만 내부 망에 접근할 수 있게 하여 외부에서 내부 망에 직접적으로 요청할 수 없도록 하여 보안을 제공한다.
          - DDOS와 같은 불필요한 요청을 사전에 필터링할 수 있다.
        - 신뢰
          - reverseProxy를 클러스터(active-standby)하여 가용성을 높일 수 있다.
          - ReverseProxy와 연결된 서버를 확장하여 트래픽을 분산시킬 수 있다.
        - 캐싱
          - 요청한 리소스를 캐싱해두었다가 was에 요청을 보내지않고 웹서버에서 리소스를 반환해줄 수 있다.
        - 빠르다(NginX)
          - 비동기 작업을 통해 트래픽을 빠르게 처리할 수 있다

    + HAProxy
      + 하드웨어 스위치를 대체하는 소프트웨어 로드밸런서
      + ReverseProxy 형태로 동작한다. 즉, 클라이언트에서 서버에게 요청을 보냈을시 중간에 HAProxy가 대신 요청을 받고 서버에게 요청을 전달한다.

    + 로드밸런싱 이중화
      + Active Proxy와 Stand by Proxy를 지정하고 Active Proxy에서 정상적으로 가상IP로 요청을 받다가 문제가 발생하면 Stand by Proxy가 Active상태가 되며 가상IP를 받아오면서 fail over 해준다.
      + <img width="500" alt="image" src="https://user-images.githubusercontent.com/57162257/200487554-c680d889-4418-4e2b-90f1-b869c676fae8.png">

  + 하드웨어

    + L4
      + OSI 7계층에서 4계층인 전송계층에서 트래픽을 분산해주는 방법
      + TCP, UDP에서 IP와 Port를 이용해 트래픽을 분산해준다.
      + 패킷 내부를 확인하지 않기 때문에 섬세한 라우팅이 불가능하지만, 패킷 레벨에서 분산을 시켜주기 때문에 빠르고 효율이 높으며 L7보다 비용이 저렴하다.
    + L7
      + OSI 7계층에서 7계층인 응용계층에서 트래픽을 분산해주는 방법
      + 패킷 내부 정보를 확인하고 URL이나 HTTP헤더를 통해 사용자의 요청 내용에 따라 특정 서버에 트래픽을 분산한다.
      + 패킷 내용을 확인하기 때문에 복호화 하는 과정이 발생하여 많은 비용이 발생하지만, 섬세한 라우팅이 가능하며 DDOS와 같은 비정상적인 트래픽을 사전에 필터링해줄 수 있다.
      + 방식
        + URL 스위칭 방식 : URL요청별로 트래픽을 분산
        + Cookie 스위칭 방식 :  Header의 쿠키를 기준으로 트래픽을 분산
        + Content 스위칭 방식 : Header와 content 기반으로 트래픽 분산

+ HAProxy(로드밸런싱)의 기능

  + NAT(Network Address Translation)
    + 사설IP를 공인 IP로 변경
    + 클라이언트가 로드밸런서의 공인IP로 요청을 보내게 되면 로드밸런서에서 사설IP와MAC주소를 변경하여 실제 서버에 요청을 전달한다.

  + DSR (Direct Server Return)
    + 서버가 클라이언트에게 결과를 반환할때, 로드밸런서를 거쳐 전달되는것이 아닌 클라이언트에게 바로 결과를 반환하는것.
    + 결과를 로드밸런서를 거쳐 전달하면 로드밸런서가 병목 지점이 될수 있는것을 방지

  + 터널링
    + 데이터를 캡슐화하여, 연결된 상호간에서만 데이터를 해제할 수 있도록 한다






</details>

-----------------------

<br>



<br>

-----------------------

### 세션 클러스터링

<details>
   <summary> 예비 답안 보기 (👈 Click)</summary>
<br />





-----------------------

+ 다중 WAS를 사용하는 경우 로드밸런싱, fail over를 위한 서버 이중화, auto scaling(ec2인스턴스를 자동으로 생성하고 삭제해주는 기술) 등의 대체 WAS에서 사용하는 세션을 하나로 관리하여 다른 WAS에서도 동일한 세션을 사용할 수 있도록 하는 기술
+ tomcat에서의 설정으로 이중화된 서버에서 세션을 공유할수 있다.
+ 로드 밸런싱은 다수의 서버에 트래픽을 분산시켜 서버의 성능 감소를 방지하기 위한 방법
+ 세션 클러스터링은 특정 서버에서 오류가 발생하였을때도 다른 서버에서도 동일한 세션을 사용할 수 있게 하여 fail over를 제공해준다. (SPOF - single point of failure)




</details>

-----------------------

<br>
